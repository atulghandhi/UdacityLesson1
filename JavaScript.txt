To declare variables use keywords var, let or const.
    var variableName = "anyting"  -> general variable when other two cant be used - don't use it if you can avoid it.
    let variableName = "anyting"  -> can be reassigned (give it a new values) - but cant be redeclared in the same scope (creating new variable with same name to overwrite it)
    const variableName = "anyting"  -> must be initialised, cant be redeclared in the same scope, cant be reassigned. basically its like a java final variable.

        use const as a default and let when const can't be used.

Hoisting: before any js code is executed, all variables declared with a 'var' are hoisted - meaning the declaration of
the variables is raised to the top of the scope of that function (decalration not initialisation as that would mess with the code
itself).

let and const variables are scoped to the block of code ( {    } ) rather than the full function.
This prevents variables from being accessed until after they've been declared - as it should be. prevents hard to find bugs.

you can concatenate strings with '+' or concat() method - but its best practice to do that shit with template literals.

template literals use back ticks instead of any type of quote marks and ${variableName} inside a template literal will summon the value
    of the variable stated. No need for further comma's or plus'.
    e.g. : const variableNameHere = `Hello, my name is ${myNameVariableDeclaredEarlier}`;

In normal strings you use \n to start a new line. not so in template literals - instead just start a new line like your
    in fucking word - with an enter - and the literal will read the new line literally!

furthermore, the variable name in the curly braces of a template literal could be replaced with a maths operation or an entire fucking loop. shits crazy powerful.

create an object then use its values:
    const gemstone = {
      type: 'quartz',
      color: 'rose',
      carat: 21.29
    };

    const type = gemstone.type;
    const color = gemstone.color;
    const carat = gemstone.carat;


Destructuring: When extracting specific values from an array or object, and saving them into separate variables you can use
    destructuring to put the elements you want to extract on the *left* side of an assignment - instead of the right.
e.g.
    const point = [10, 25, -34];
    const [x, y, z] = point;

    The above will save 10 into a const named x, 25 in y and -34 in z. You can also ignore values when destructuring arrays.
        For example, const [x, , z] = point; ignores the y coordinate and discards it.

e.g.
    const gemstone = {
      type: 'quartz',
      color: 'rose',
      carat: 21.29
    };
    const {type, color, carat} = gemstone;

    In this example, the curly braces { } represent the object being destructured and type, color, and carat represent the
        variables where you want to store the properties from the object. Notice how you don’t have to specify the property from
        where to extract the values. Because gemstone has a property named type, the value is automatically stored in the type
        variable. Similarly, gemstone has a color property, so the value of color automatically gets stored in the color variable.
        And it's the same with carat.

Objects can be shortened when writing them out. For example;
    let type = 'quartz';
    let color = 'rose';
    let carat = 21.29;

    const gemstone = {
      type: type,
      color: color,
      carat: carat
    };

can also be written as :
    let type = 'quartz';
    let color = 'rose';
    let carat = 21.29;

    let gemstone = {
      type,
      color,
      carat,
      calculateWorth() { ... }
    };

LOOPS:

A for-loop:
    for (let i = 0; i < array.length; i++) {
      console.log(array[i]);
    }

The counter(i) and the exit condition(array.length) can be confusing. You still have to deal with the issue of index
    meddling with the array.

An alternative is for-in loops which will iterate over the index of an array. To be clear, it wont loop over the data
    at a particular index but the index itself. But the index can be used to access the data so some thing:
    const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
        for (const index in digits) {
          console.log(digits[index]);
        }
    An additional issue the for-in loop is that it iterates over all values in the array. Including any methods or
        properties you may have given the array. This may be undesired.

And then there is for-of loop. This is a loop that iterates over the content stored within each array unit:
    for (const digit of digits) {
      console.log(digit);
    }

forEach loop also exists - it can only be used with arrays and there's no way to stop or break it. For-of is better.

    if(digit % 2 === 0) <--- this is a true if statement for 2, 4, 6 etc.


Writing better code:
    const upperDay = day.charAt(0).toUpperCase() + day.slice(1);

Spread operator
    const fruits = ["apples", "bananas", "pears"];
    const vegetables = ["corn", potatoes, carrots];

    const produce = [...fruits, ...vegetables];

    This operator, among other things, combines arrays

Rest parameter
    const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
    const [total, subtotal, tax, ...items] = order;

    This code takes the values of the 'order' array and assigns the first 3 to individual variables, then the rest to a
        separate array called 'items' using the rest parameter.

    You can also write a function that takes as argument any number of variables by including a Rest parameter.

Arguments object
    The arguments object is an array-like local variable inside all functions (called 'arguments'). It contains an
        indexed value for each argument passed to the function. e.g.
            function sum() {
              let total = 0;
              for(const argument of arguments) {
                total += argument;
              }
              return total;
            }

    The issue with the above function is that sum doesn't have parameters (confusing...) and arguments seems to appear
        out of nowhere (confusing...) .
    You can fix both of those issues with a simple refactoring:
            function sum(...nums) {
              let total = 0;
              for(const num of nums) {
                total += num;
              }
              return total;
            }



THE DOM:

When a html page is requested, the browser does the following:
    HTML is received
    HTML tags are converted to tokens
    Tokens are converted to Nodes
    Nodes are converted to the DOM

When you request a website, no matter what backend language is powering that website, it will respond with HTML. The
    browser receives a stream of HTML. The bytes are run through a complicated (but fully documented) parsing process that
    determines the different characters (e.g. the start tag character <, an attribute like href, a closing angle bracket
    like >). After parsing has occurred, a process called tokenization begins. Tokenization takes one character at a time
    and builds up tokens.

At this stage, the browser has received the bytes that have been sent by a server. The browser has converted the bytes to
    tags and has read through the tags to create a list of tokens. This list of tokens then goes through the tree
    construction stage. The output of this stage is a tree-like structure - this is the DOM!

The DOM is accessible in javascript via the global 'document' object.

The 'document' object is an object, just like a JavaScript object. This means it has key/value pairs. Some of the values
    are just pieces of data, while others are functions (AKA methods!) that provide some type of functionality.

The first DOM method that we'll be looking at is the .getElementById() method: document.getElementById('navbar');

Running this code caused the document object to search through its entire tree-like structure for the element that has
    an ID of "navBar". If navBar doesn't exist then it'll return null.

You can store an element returned via getElementById() inside a const or let variable and access it later. i.e.
    const navBar = document.getElementById('navbar');
    print(navBar); //this like is for illustration purposes only...

ID's are unique. Theres only one element with a given ID on a page. So, when you need to return multiple elements, use
    the following methods:

    .getElementsByClassName()   //notice element'S' instead of element previously
    .getElementsByTagName()     //notice element'S' instead of element previously
                                //also note that its TagName and ClassName - not just Tag and Class

Putting the class name method to use we get:
    document.getElementsByClassName('story_box');
The above will return an HTMLCollection list of elements with the 'story_box' class.

And, finally, using the tag name method...
    document.getElementsByTagName('p');
This will return a HTMLCollection of all elements composed of the 'p' tag.

A Node in the DOM is javascripts version of an objects class, and a node (lowercase n) is an object created from that class.

The Node is like a superclass for lesser objects. It has some default variables and methods that all objects have, and other
    objects, like 'Element' inherit from it. Meaning any element object also inherits from 'Node' and in the way of polymorphism,
    *is* a node.

Elements objects also have a .getElementsByClassName() method, so you can select an element from the document object and then
    use the same method on the returned element to get a list of elements of a particular class that are descendants of it.

There are a fuck-ton of 'interfaces' like Node and Element in JS - use to WebAPI page to view them.

The querySelector Method
We can use the .querySelector() method to select elements just like we do with CSS by passing to it a string that's just like a CSS selector:

find and return the element with an ID of "header"
    document.querySelector('#header');

find and return the first element with the class "header"
    document.querySelector('.header');

find and return the first <header> element
    document.querySelector('header');

The issue with the above is the .querySelector only returns one argument. Give at a class or tag and it will return the first argument it
    finds that matches your provided class or tag.

To find the first paragraph element with a class of callout:
    document.querySelector('p.callout');

To get all elements of a certain tag or class, and use CSS rules, use the querySelectorAll() method

find and return a list of elements with the class "header"
    document.querySelectorAll('.header');

find and return a list of <header> elements
    document.querySelectorAll('header');

The returned list of elements from querySelectorAll is of type 'NodeList' - which has a built in forEach method (among others)
A NodeList behaves just like an array, has the same methods(.length) and uses the same index system to get individual elements[].

Since every element inherits from the Element 'interface', they also inherit the .innerHTML property(variable). This property
    contains a string with the elements HTML in it (as well as any elements contained inside it). It can be used to set the HTML of an element.
There exists also outerHTML which includes the tags of the element it is called on - inner html contains just its content within those tags.
And there is textContent property - which returns only the displayed to screen text of an element. You can set any of these properties to a new values like below:
    const card = document.querySelector('.card')
    card.textContent = "I am UPDATED";

Passing any text that looks like HTML to the .textContent property will still be displayed as text. It will not be displayed as HTML when the element is rendered.
To change an elements html content you need to set the innerHTML property.

There is also an innerText property, this one returns the text of an element as it would be seen visually (text content returns it as is).
    This means innerText will not show text the has css property 'display none' because that text isn't displayed.

CREATING AND ADDING NEW ELEMENTS TO PAGE

You create an element ise the createElement() method like so:

// create a brand new <span> element
    const newSpan = document.createElement('span');

Then, you need to get another element that you want it to be a child of:

// select the first (main) heading of the page
    const mainHeading = document.querySelector('h1');

Then, you use the appendChild() method to add your new element to the end of another elements descendants.

// add the <span> element as the last child element of the main heading
    mainHeading.appendChild(newSpan);

The createTextNode method creates..you guessed it, textNodes! Now you're wondering what the fuck a textNode is. I don't know
    either but lets read on and find out... Basically, a text node is plain text that you apend to an element like paragraph
    before you append the paragraph to another element.

// create a paragraph element
    const myPara = document.createElement('p');
// create a text node
    const textOfParagraph = document.createTextNode('I am the text for the paragraph!');
// append the text node to the paragraph
    myPara.appendChild(textOfParagraph);
// append the paragraph to the body tag
    document.body.appendChild(myPara);

However, this is useless because its much faster to just edit the textContent property of the paragraph element you created.
    const myPara = document.createElement('p');
    myPara.textContent = 'I am the text for the paragraph!';
    document.body.appendChild(myPara);

If you try and append the same element to two other elements; append child will move the element from one to the other; basically
only the final element to be appended by your element will keep the element.

.appendchild() only adds the element to the end of the tag its appended to. To add an element anywhere else you need to use the
    .insertAdjacentHTML() method.

The .insertAdjacentHTML() method has to be called with two arguments:
    the location of the HTML
    the HTML text that is going to be inserted

The first argument to this method will let us insert the new HTML in one of four different locations
    beforebegin – inserts the HTML text as a previous sibling
    afterbegin – inserts the HTML text as the first child
    beforeend – inserts the HTML text as the last child
    afterend – inserts the HTML text as a following sibling

An example using this would be:
    const mainHeading = document.querySelector('#main-heading');
    const htmlTextToAdd = '<h2>Skydiving is fun!</h2>';
    mainHeading.insertAdjacentHTML('afterend', htmlTextToAdd);

If an element already exists in the DOM and this element is passed to .appendChild(), the .appendChild() method will
    move it rather than duplicating it

The .insertAdjacentHTML() method's second argument has to be text, you can't pass an element

REMOVING ELEMENTS:

The removeChild() property can be used to remove a child
    <parent-element>.removeChild(<child-to-remove>);

You do not need to know what the parent element is of the child you want to remove. Just use the parentElement property!
    const mainHeading = document.querySelector('h1');
    mainHeading.parentElement.removeChild(mainHeading);

Or you can use the elements own remove method to remove it directly. Much quicker!
    const mainHeading = document.querySelector('h1');
    mainHeading.remove();

To get the first child of an element use the firstElementChild property.
    The difference between .firstChild and .firstElementChild, is that .firstElementChild will always return the first element,
    while .firstChild might return whitespace (if there is any) to preserve the formatting of the underlying HTML source code.



















