To declare variables use keywords var, let or const.
    var variableName = "anyting"  -> general variable when other two cant be used - don't use it if you can avoid it.
    let variableName = "anyting"  -> can be reassigned (give it a new values) - but cant be redeclared in the same scope (creating new variable with same name to overwrite it)
    const variableName = "anyting"  -> must be initialised, cant be redeclared in the same scope, cant be reassigned. basically its like a java final variable.

        use const as a default and let when const can't be used.

Hoisting: before any js code is executed, all variables declared with a 'var' are hoisted - meaning the declaration of
the variables is raised to the top of the scope of that function (decalration not initialisation as that would mess with the code
itself).

let and const variables are scoped to the block of code ( {    } ) rather than the full function.
This prevents variables from being accessed until after they've been declared - as it should be. prevents hard to find bugs.

you can concatenate strings with '+' or concat() method - but its best practice to do that shit with template literals.

template literals use back ticks instead of any type of quote marks and ${variableName} inside a template literal will summon the value
    of the variable stated. No need for further comma's or plus'.
    e.g. : const variableNameHere = `Hello, my name is ${myNameVariableDeclaredEarlier}`;

In normal strings you use \n to start a new line. not so in template literals - instead just start a new line like your
    in fucking word - with an enter - and the literal will read the new line literally!

furthermore, the variable name in the curly braces of a template literal could be replaced with a maths operation or an entire fucking loop. shits crazy powerful.

create an object then use its values:
    const gemstone = {
      type: 'quartz',
      color: 'rose',
      carat: 21.29
    };

    const type = gemstone.type;
    const color = gemstone.color;
    const carat = gemstone.carat;


Destructuring: When extracting specific values from an array or object, and saving them into separate variables you can use
    destructuring to put the elements you want to extract on the *left* side of an assignment - instead of the right.
e.g.
    const point = [10, 25, -34];
    const [x, y, z] = point;

    The above will save 10 into a const named x, 25 in y and -34 in z. You can also ignore values when destructuring arrays.
        For example, const [x, , z] = point; ignores the y coordinate and discards it.

e.g.
    const gemstone = {
      type: 'quartz',
      color: 'rose',
      carat: 21.29
    };
    const {type, color, carat} = gemstone;

    In this example, the curly braces { } represent the object being destructured and type, color, and carat represent the
        variables where you want to store the properties from the object. Notice how you donâ€™t have to specify the property from
        where to extract the values. Because gemstone has a property named type, the value is automatically stored in the type
        variable. Similarly, gemstone has a color property, so the value of color automatically gets stored in the color variable.
        And it's the same with carat.

Objects can be shortened when writing them out. For example;
    let type = 'quartz';
    let color = 'rose';
    let carat = 21.29;

    const gemstone = {
      type: type,
      color: color,
      carat: carat
    };

can also be written as :
    let type = 'quartz';
    let color = 'rose';
    let carat = 21.29;

    let gemstone = {
      type,
      color,
      carat,
      calculateWorth() { ... }
    };

A for-loop:
    for (let i = 0; i < array.length; i++) {
      console.log(array[i]);
    }

The counter(i) and the exit condition(array.length) can be confusing.

You still have to deal with the issue of index meddling with the array.
    const digits = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
    for (const index in digits) {
      console.log(digits[index]);
    }

forEach loop also exists - it can only be used with arrays and there's no way to stop or break it.

    if(digit % 2 === 0) <--- this is a true if statement for 2, 4, 6 etc.

A better loop:
    for (const digit of digits) {
      console.log(digit);
    }

Writing better code:
    const upperDay = day.charAt(0).toUpperCase() + day.slice(1);

Spread operator
    const fruits = ["apples", "bananas", "pears"];
    const vegetables = ["corn", potatoes, carrots];

    const produce = [...fruits, ...vegetables];

    This operator, among other things, combines arrays

Rest parameter
    const order = [20.17, 18.67, 1.50, "cheese", "eggs", "milk", "bread"];
    const [total, subtotal, tax, ...items] = order;
    console.log(total, subtotal, tax, items);

    This code takes the values of the order array and assigns them to individual variables. By using the rest parameter,
        items are assigned the rest of the values in the array (as an array).
























































